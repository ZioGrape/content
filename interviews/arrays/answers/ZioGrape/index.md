Для решения этой задачи важно понимать, что массивы в JavaScript — это объекты с числовыми ключами, которые автоматически создаются при инициализации и могут изменяться при мутации массива его методами.

Как это выглядит:
```js
  const arr = [1, 2]
```
Для движка, который обрабатывает JavaScript, массив arr выглядит примерно так:
```js
const arr = {
  '0': 1,
  '1': 2,
  'length': 2
}
```
Ключи "0" и "1" — это строки, соответствующие индексам массива.
Свойство ```length``` указывает на наибольший индекс + 1.

Как мы знаем, если обратиться к несуществующему ключу в объекте, результатом будет ```undefined```.
Например:

```js
  const obj = {}
  console.log(obj['nonexistentKey']) // undefined
```
Аналогично для массивов:
```js
  const arr = [1, 2]
  console.log(arr[10]) // undefined
```
Но в случае массивов, если между существующими индексами есть разрывы ```например [1, , 3]```, JavaScript не создаёт ключ для пропущенного индекса. Это означает, что такие слоты считаются "пустыми".

```js
  const sparseArr = [1, , 3]
  console.log(sparseArr.length) // 3
  console.log(sparseArr) // [1, empty, 3]
  console.log(sparseArr[1]) // undefined
```
Для движка массив sparseArr будет выглядеть так:
```js
{
  '0': 1,
  '2': 3,
  'length': 3
}
```
Важно: ```empty``` — это не отдельный тип данных. Это просто обозначение отсутствия ключа для индекса в массиве.


Решение задачи:

```js
function countEmptySpacesInSparseArray(arr) {
  let count = 0
  for (let i = 0; i < arr.length; i++) {
    // Проходясь по всей длине массива проверяем, отсутствует ли у него ключ равный индексу
    const isEmptySpace = !arr.hasOwnProperty(i)
    if (isEmptySpace) {
      // В случае отсутствия ключа увеличиваем значение счетчика
      count++
    }
  }
  return count
}
```

Еще можно решить таким способом:

Некоторые методы массива, из более ранней версии языка, умеют отличать ```empty``` от хранящегося в массиве ```undefined```.

Можно увидеть на примере ```sort()``` и более новго ```toSorted()```.

```js
const colors = ['red', 'yellow', 'blue', undefined]
colors[6] = 'purple'
colors.toSorted() // ['blue', purple, 'red', 'yellow', undefined, undefined, undefined]
colors.sort() //  ['blue', purple, 'red', 'yellow', undefined, empty x 2]
```

Как видишь, ```toSorted()``` превратил наши ```empty``` в ```undefined```, что в дальнейшем нам никак не поможет.
Но и ```sort()``` хоть и может определить ```empty```, не убирает их из массива.

И тут нам подойдет метод ```flat()``` который преобразует массив и его подмассивы в единый массив до заданного уровня вложенности. Его особенность заключается в рекурсивной обработке структуры массива, в отличие от других методов, которые работают итеративно. При этом ```flat()``` полностью игнорирует пустые места.

```js
function countEmptySpacesInSparseArray(arr) {
  const arrWithoutEmptyItems = arr.flat(0)
  // Находим количество пустых мест, путем исключения заполненных мест из общего количества
  return arr.length - arrWithoutEmptyItems.length
}
```

Примечание: оба решения имеют алгоритмическую сложность O(n).
